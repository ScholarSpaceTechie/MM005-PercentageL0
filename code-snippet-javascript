(function () {
  function initPercentageGame() {
    const container = document.getElementById("percentage-game-container");
    if (!container) return;

    // ---------- HTML ----------
    container.innerHTML = `
      <div class="sf-game sfp-theme">
        <div class="sf-title-row">
          <h2 class="sf-title">
            <span>‚ö°</span>
            <span style="color:#ffffff">Game ‚Äî Percent Power-Up!</span>
            <span class="sf-tag sfp-tag">MM005</span>
          </h2>

          <div class="sf-scoreboard">
            <div class="sf-pill" id="sf-score">Score: 0 / 0</div>
            <div class="sf-pill" id="sf-streak">Streak: 0 üî•</div>
            <div class="sf-pill sf-timer" id="sf-timer">‚è± ‚Äì</div>
          </div>
        </div>

        <div class="sf-control-row">
          <div class="sf-control">
            <label for="sf-topic">Topic:</label>
            <select id="sf-topic">
              <option value="mixed" selected>Mixed (All)</option>
              <option value="discount">Discount</option>
              <option value="increase">Increase</option>
              <option value="reverse">Find Original</option>
              <option value="of">% of a Number</option>
              <option value="gst">GST</option>
            </select>
          </div>

          <div class="sf-control">
            <label for="sf-mode">Mode:</label>
            <select id="sf-mode">
              <option value="warmup">Warm-Up (No Timer)</option>
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
            </select>
          </div>
        </div>

        <div class="sf-question-box">
          <div class="sf-q-left">
            <div class="sf-sub" id="sf-instructions">
              10 questions per quiz. Pick the best answer. (No answer reveal)
            </div>

            <div class="sf-question-row">
              <div class="sf-question" id="sf-question">‚Äî</div>
              <div class="sf-shape" id="sf-shape" aria-hidden="true"></div>
            </div>
          </div>

          <div class="sf-q-right">
            <div class="sf-meta" id="sf-meta">Ready</div>
            <div class="sf-hint" id="sf-hint" aria-live="polite"></div>
          </div>
        </div>

        <div class="sf-options" id="sf-options"></div>

        <div class="sf-bottom">
          <div class="sf-feedback" id="sf-feedback"></div>

          <div class="sf-buttons">
            <button class="sf-btn sf-primary sfp-primary" id="sf-next">Start Quiz ‚ñ∂</button>
            <button class="sf-btn sf-secondary" id="sf-reset">Reset üîÑ</button>
          </div>
        </div>
      </div>
    `;

    // ---------- CSS (ONLY right glow changed to orange; buttons untouched) ----------
    const styleId = "sf-percentage-style-mm005";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.innerHTML = `
        /* Base (keeps your sf- layout) */
        .sf-game{
          color:#e5e7eb;
          padding:24px;
          border-radius:18px;
          max-width:980px;
          margin:24px auto;
          position:relative;
          overflow:hidden;
          border:1px solid rgba(148,163,184,0.25);
          box-shadow:0 18px 45px rgba(0,0,0,.55);
        }

        /* THEME (left purple stays; right changed to orange) */
        .sfp-theme{
          background: radial-gradient(1200px 600px at 20% 0%, rgba(168,85,247,.18), transparent 55%),
                      radial-gradient(900px 520px at 90% 20%, rgba(255,159,67,.18), transparent 55%),
                      linear-gradient(180deg, #120a2a 0%, #070a14 100%);
          border-color: rgba(255,255,255,0.12);
        }
        .sfp-tag{
          border:1px solid rgba(255,183,3,0.55);
          background:rgba(255,183,3,0.14);
          color:#ffe8a3;
        }
        /* DO NOT change button colour/shape */
        .sfp-primary{
          background:linear-gradient(135deg,#FFB703,#00D1FF);
          color:#06101f;
        }

        .sf-title-row{
          display:flex;
          justify-content:space-between;
          align-items:center;
          gap:12px;
          flex-wrap:wrap;
        }
        .sf-title{
          margin:0;
          display:flex;
          align-items:center;
          gap:10px;
          font-size:1.45rem;
        }
        .sf-tag{
          font-size:.78rem;
          padding:3px 10px;
          border-radius:999px;
        }

        .sf-scoreboard{
          display:flex;
          gap:8px;
          align-items:center;
          flex-wrap:wrap;
        }
        .sf-pill{
          font-size:.86rem;
          padding:5px 12px;
          border-radius:999px;
          border:1px solid rgba(148,163,184,0.28);
          background:rgba(15,23,42,0.65);
        }
        .sf-timer{
          border-color:rgba(34,197,94,0.35);
          background:rgba(34,197,94,0.12);
          color:#d1fae5;
        }

        .sf-control-row{
          margin-top:12px;
          display:flex;
          gap:12px;
          flex-wrap:wrap;
          align-items:center;
        }
        .sf-control{
          display:flex;
          gap:8px;
          align-items:center;
          font-size:.9rem;
        }
        .sf-control select{
          background:#050b16;
          color:#e5e7eb;
          border:1px solid rgba(148,163,184,0.35);
          border-radius:999px;
          padding:4px 12px;
          font-size:.9rem;
          outline:none;
        }

        .sf-question-box{
          margin-top:14px;
          padding:14px;
          border-radius:14px;
          border:1px solid rgba(148,163,184,0.25);
          background:rgba(2,6,23,0.65);
          display:flex;
          justify-content:space-between;
          gap:16px;
          flex-wrap:wrap;
        }
        .sf-q-left{min-width:280px;flex:1;}
        .sf-sub{font-size:.92rem;opacity:.9;margin-bottom:6px;}
        .sf-question-row{
          display:flex;
          gap:14px;
          align-items:center;
          justify-content:space-between;
          flex-wrap:wrap;
        }
        .sf-question{
          font-size:1.22rem;
          font-weight:700;
          letter-spacing:.2px;
          flex: 1;
          min-width: 240px;
        }
        .sf-shape{width: 170px;max-width: 100%;display:flex;justify-content:flex-end;}
        .sf-q-right{min-width:260px;}
        .sf-meta{font-size:.95rem;opacity:.9;}
        .sf-hint{
          margin-top:8px;
          font-size:.92rem;
          color:#c7d2fe;
          min-height:18px;
        }

        .sf-options{
          margin-top:14px;
          display:grid;
          grid-template-columns:repeat(2,1fr);
          gap:10px;
        }
        .sf-option{
          position:relative;
          border-radius:14px;
          border:1px solid rgba(148,163,184,0.25);
          background:rgba(15,23,42,0.55);
          padding:12px 12px 12px 46px;
          cursor:pointer;
          transition:transform .12s, border-color .12s, box-shadow .12s;
          user-select:none;
        }
        .sf-option:hover{
          transform:translateY(-2px);
          border-color:rgba(0,209,255,0.55);
          box-shadow:0 10px 24px rgba(0,0,0,.45);
        }
        .sf-option.correct{
          border-color:rgba(34,197,94,0.9) !important;
          box-shadow:0 0 0 2px rgba(34,197,94,0.25), 0 14px 28px rgba(0,0,0,.45);
        }
        .sf-option.wrong{
          border-color:rgba(239,68,68,0.9) !important;
          box-shadow:0 0 0 2px rgba(239,68,68,0.2), 0 14px 28px rgba(0,0,0,.45);
        }
        .sf-letter{
          position:absolute;
          left:12px;
          top:10px;
          width:26px;
          height:26px;
          border-radius:999px;
          display:flex;
          align-items:center;
          justify-content:center;
          font-weight:800;
          font-size:.9rem;
          border:1px solid rgba(148,163,184,0.35);
          background:rgba(2,6,23,0.65);
          color:#e5e7eb;
        }
        .sf-formula{font-size:1.08rem;font-weight:750;letter-spacing:.2px;}
        /* ‚úÖ no labels like Trap / Total Bill */
        .sf-desc{display:none;}

        .sf-bottom{
          margin-top:12px;
          display:flex;
          justify-content:space-between;
          align-items:center;
          gap:10px;
          flex-wrap:wrap;
        }
        .sf-feedback{min-height:22px;font-size:1rem;}
        .sf-buttons{display:flex;gap:10px;flex-wrap:wrap;}
        .sf-btn{
          border:none;
          border-radius:999px;
          padding:8px 16px;
          cursor:pointer;
          font-weight:700;
        }
        .sf-primary:hover{
          transform:translateY(-1px);
          box-shadow:0 10px 24px rgba(0,209,255,.20);
        }
        .sf-secondary{
          background:rgba(2,6,23,0.65);
          border:1px solid rgba(148,163,184,0.35);
          color:#e5e7eb;
        }
        .sf-secondary:hover{background:rgba(15,23,42,0.7);}

        .sf-confetti{
          position:fixed;
          z-index:99999;
          pointer-events:none;
          animation:sf-confetti-fall 1.8s ease-out forwards;
          font-size:1.7rem;
        }
        @keyframes sf-confetti-fall{
          0%{transform:translateY(-10vh) rotate(0deg);opacity:0;}
          10%{opacity:1;}
          100%{transform:translateY(110vh) rotate(340deg);opacity:0;}
        }
        .sf-stream{
          position:fixed;
          z-index:99999;
          pointer-events:none;
          font-size:1.7rem;
          user-select:none;
          will-change:transform, opacity;
        }

        @media(max-width:820px){
          .sf-options{grid-template-columns:1fr;}
        }
      `;
      document.head.appendChild(style);
    }

    // ---------- DATA / SETTINGS ----------
    const letters = ["A", "B", "C", "D", "E", "F", "G", "H"];
    const emojis = ["üéâ", "üéä", "üéà", "‚ú®", "üí´", "üåü", "ü§©", "üíØ", "ü•á", "ü•à", "ü•â"];

    const DIFF = {
      warmup: { time: 0 },
      easy: { time: 60 },
      normal: { time: 45 },
      hard: { time: 30 },
    };

    // ---------- ELEMENTS ----------
    const topicSel = document.getElementById("sf-topic");
    const modeSel = document.getElementById("sf-mode");

    const scoreEl = document.getElementById("sf-score");
    const streakEl = document.getElementById("sf-streak");
    const timerEl = document.getElementById("sf-timer");

    const questionEl = document.getElementById("sf-question");
    const metaEl = document.getElementById("sf-meta");
    const hintEl = document.getElementById("sf-hint");
    const feedbackEl = document.getElementById("sf-feedback");
    const optionsEl = document.getElementById("sf-options");

    const nextBtn = document.getElementById("sf-next");
    const resetBtn = document.getElementById("sf-reset");

    // ---------- STATE ----------
    const TOTAL_QUESTIONS = 10;
    const OPTIONS_COUNT = 8;

    let inProgress = false;
    let locked = false;
    let attemptedThisQ = false;

    let score = 0;
    let total = 0;
    let streak = 0;
    let qIndex = 0;

    let timerId = null;
    let timeLeft = 0;

    let current = null;

    // ---------- AUDIO ----------
    let audioCtx = null;
    function canUseAudio() {
      return typeof window !== "undefined" && (window.AudioContext || window.webkitAudioContext);
    }
    function beep(freq, dur, type = "sine", delay = 0, vol = 0.08) {
      if (!canUseAudio()) return;
      try {
        if (!audioCtx) {
          const AC = window.AudioContext || window.webkitAudioContext;
          audioCtx = new AC();
        }
        const start = audioCtx.currentTime + delay / 1000;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = vol;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(start);
        osc.stop(start + dur / 1000);
      } catch (e) {}
    }
    function playCorrectSound() {
      beep(660, 220, "sine", 0, 0.07);
      beep(880, 240, "sine", 140, 0.07);
      beep(1040, 280, "sine", 280, 0.06);
    }
    function playWrongSound() {
      beep(260, 200, "triangle", 0, 0.07);
      beep(200, 200, "triangle", 160, 0.06);
    }
    function playTimeUpSound() {
      beep(520, 220, "sine", 0, 0.06);
      beep(400, 260, "sine", 200, 0.06);
    }

    // ---------- CONFETTI ----------
    function shootPopperStream(originX, originY, side, totalCount) {
      let count = 0;
      const interval = setInterval(() => {
        if (count >= totalCount) { clearInterval(interval); return; }
        const span = document.createElement("span");
        span.className = "sf-stream";
        span.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        document.body.appendChild(span);

        const startX = originX + (Math.random() - 0.5) * 16;
        const startY = originY + (Math.random() - 0.5) * 16;

        const screenW = window.innerWidth || 1200;
        const screenH = window.innerHeight || 800;

        const targetX = screenW * 0.5 + (Math.random() - 0.5) * screenW * 0.25;
        const targetY = screenH * 0.32 + (Math.random() - 0.5) * screenH * 0.12;

        const controlX = side === "left"
          ? screenW * 0.28 + Math.random() * screenW * 0.12
          : screenW * 0.72 - Math.random() * screenW * 0.12;
        const controlY = screenH * 0.12 + Math.random() * screenH * 0.1;

        const startTime = performance.now();
        const duration = 900 + Math.random() * 350;

        function animate(now) {
          const tRaw = (now - startTime) / duration;
          if (tRaw >= 1) { span.remove(); return; }
          const t = 1 - Math.pow(1 - tRaw, 2);
          const u = 1 - t;

          const x = u * u * startX + 2 * u * t * controlX + t * t * targetX;
          const y = u * u * startY + 2 * u * t * controlY + t * t * targetY;

          span.style.left = x + "px";
          span.style.top = y + "px";

          let opacity = t < 0.55 ? 1 : 1 - (t - 0.55) / 0.45;
          span.style.opacity = String(Math.max(0, Math.min(1, opacity)));

          requestAnimationFrame(animate);
        }
        span.style.opacity = "1";
        requestAnimationFrame(animate);
        count++;
      }, 24);
    }

    function launchConfetti(intensity) {
      const base = 20;
      const factor = intensity || 1;
      const count = Math.max(10, Math.round(base * factor));

      for (let i = 0; i < count; i++) {
        const span = document.createElement("span");
        span.className = "sf-confetti";
        span.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        span.style.left = Math.random() * 100 + "vw";
        span.style.top = Math.random() * 5 - 10 + "vh";
        span.style.animationDelay = Math.random() * 0.7 + "s";
        span.style.animationDuration = 1.4 + Math.random() * 0.8 + "s";
        document.body.appendChild(span);
        setTimeout(() => span.remove(), 2200);
      }

      const h = window.innerHeight || 800;
      const w = window.innerWidth || 1200;
      const totalPerSide = 12 + Math.round(5 * factor);
      shootPopperStream(80, h - 80, "left", totalPerSide);
      shootPopperStream(w - 80, h - 80, "right", totalPerSide);
    }

    // ---------- HELPERS ----------
    function getModeCfg() { return DIFF[modeSel.value] || DIFF.normal; }
    function isWarmup() { return modeSel.value === "warmup"; }

    function enforceTopicRules() {
      // Easy/Normal/Hard: force Mixed + lock. Warm-up: allow switching.
      if (isWarmup()) {
        topicSel.disabled = false;
      } else {
        topicSel.value = "mixed";
        topicSel.disabled = true;
      }
    }

    function fmtMoney(n) {
      const v = Math.round(n * 100) / 100;
      return "S$" + (Number.isInteger(v) ? v.toFixed(0) : v.toFixed(2));
    }
    function round2(n) { return Math.round(n * 100) / 100; }

    function updateScore() {
      scoreEl.textContent = Score: ${score} / ${total};
      streakEl.textContent = Streak: ${streak} üî•;
    }

    function stopTimer() {
      if (timerId) clearInterval(timerId);
      timerId = null;
    }
    function startTimer() {
      stopTimer();
      const cfg = getModeCfg();
      timeLeft = cfg.time;

      if (isWarmup() || cfg.time <= 0) {
        timerEl.textContent = "‚òï Warm-Up (No Timer)";
        return;
      }

      timerEl.textContent = ‚è± ${timeLeft}s;
      timerId = setInterval(() => {
        timeLeft--;
        if (timeLeft <= 0) {
          timeLeft = 0;
          timerEl.textContent = "‚è± 0s";
          stopTimer();
          timeUp();
        } else {
          timerEl.textContent = ‚è± ${timeLeft}s;
        }
      }, 1000);
    }

    function timeUp() {
      if (locked || isWarmup() || !inProgress) return;
      locked = false;
      feedbackEl.textContent = "‚è∞ Time‚Äôs up! You can still answer for 0.5 points.";
      playTimeUpSound();
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function renderOptions(optionObjs, correctIndex) {
      optionsEl.innerHTML = "";
      optionObjs.forEach((opt, i) => {
        const card = document.createElement("div");
        card.className = "sf-option";
        card.dataset.correct = (i === correctIndex) ? "1" : "0";
        card.innerHTML = 
          <div class="sf-letter">${letters[i] || "?"}</div>
          <div class="sf-formula">${opt.main}</div>
          <div class="sf-desc"></div>
        ;
        card.addEventListener("click", () => handlePick(card));
        optionsEl.appendChild(card);
      });
    }

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function uniqueStrings(seedArr, correct) {
      const out = [];
      const seen = new Set([correct]);
      seedArr.forEach(s => {
        if (!seen.has(s)) { seen.add(s); out.push(s); }
      });
      return out;
    }

    // no giveaway labels at all
    function make8OptionsFromCorrect(correctMain, wrongMains) {
      const correctObj = { main: correctMain, sub: "" };
      const wrongObjs = wrongMains.map(x => ({ main: x, sub: "" }));

      while (wrongObjs.length < 7) {
        wrongObjs.push({ main: wrongMains[wrongObjs.length % wrongMains.length], sub: "" });
      }

      const tagged = [correctObj].concat(wrongObjs.slice(0, 7)).map((o, i) => ({ o, i }));
      const shuffled = shuffle(tagged);
      const newCorrectIndex = shuffled.findIndex(x => x.i === 0);

      return { options: shuffled.map(x => x.o), correctIndex: newCorrectIndex };
    }

    // ---------- QUESTION GENERATORS ----------
    function genDiscount(mode) {
      const base = mode === "hard" ? [48, 56, 72, 84, 96][randInt(0,4)] : [20, 30, 40, 50, 60][randInt(0,4)];
      const p = mode === "easy" ? [10, 20, 25][randInt(0,2)] : [10, 15, 20, 25, 30][randInt(0,4)];
      const newPrice = round2(base * (1 - p / 100));
      const correct = fmtMoney(newPrice);

      const wrongSeeds = [
        fmtMoney(round2(base - (p/100)*base + 1)),
        fmtMoney(round2(base - (p/100)*base - 1)),
        fmtMoney(round2(base * (1 - (p + 10)/100))),
        fmtMoney(round2(base - p)),
        fmtMoney(round2(base)),
        fmtMoney(round2(newPrice + 2)),
        fmtMoney(round2(Math.max(0, newPrice - 2))),
        fmtMoney(round2(base * (1 - p/200))),
        fmtMoney(round2(base * (1 - (Math.max(5, p - 5))/100))),
      ];
      const wrong = uniqueStrings(wrongSeeds, correct).slice(0, 12);
      const built = make8OptionsFromCorrect(correct, wrong);

      return {
        q: An item costs <b>${fmtMoney(base)}</b>. It is discounted by <b>${p}%</b>. What is the sale price?,
        hint: ${p}% of ${base} = ${(p/100)*base}. Subtract from ${base}.,
        options: built.options,
        correctIndex: built.correctIndex
      };
    }

    function genIncrease(mode) {
      const base = mode === "hard" ? [55, 65, 75, 95, 110][randInt(0,4)] : [30, 40, 50, 60, 80][randInt(0,4)];
      const p = mode === "easy" ? [10, 20, 25][randInt(0,2)] : [10, 15, 20, 25, 30][randInt(0,4)];
      const newPrice = round2(base * (1 + p / 100));
      const correct = fmtMoney(newPrice);

      const wrongSeeds = [
        fmtMoney(round2(base + (p/100)*base + 1)),
        fmtMoney(round2(base + (p/100)*base - 1)),
        fmtMoney(round2(base * (1 + (p + 10)/100))),
        fmtMoney(round2(base + p)),
        fmtMoney(round2(base * (1 + p/200))),
        fmtMoney(round2(base)),
        fmtMoney(round2(newPrice + 2)),
        fmtMoney(round2(Math.max(0, newPrice - 2))),
        fmtMoney(round2(base * (1 + (Math.max(5, p - 5))/100))),
      ];
      const wrong = uniqueStrings(wrongSeeds, correct).slice(0, 12);
      const built = make8OptionsFromCorrect(correct, wrong);

      return {
        q: A price is <b>${fmtMoney(base)}</b>. It increases by <b>${p}%</b>. What is the new price?,
        hint: ${p}% of ${base} then add to ${base}.,
        options: built.options,
        correctIndex: built.correctIndex
      };
    }

    function genReverse(mode) {
      const p = mode === "easy" ? [20, 25][randInt(0,1)] : [10, 15, 20, 25, 30][randInt(0,4)];
      const original = mode === "hard" ? [60, 75, 90, 120, 150][randInt(0,4)] : [30, 40, 50, 80, 100][randInt(0,4)];
      const paid = round2(original * (1 - p / 100));
      const correct = fmtMoney(original);

      const wrongSeeds = [
        fmtMoney(paid),
        fmtMoney(round2(original + 10)),
        fmtMoney(round2(Math.max(0, original - 10))),
        fmtMoney(round2(paid / (1 - (p+10)/100))),
        fmtMoney(round2(paid / (1 - (p-5)/100))),
        fmtMoney(round2(paid * (1 + p/100))),
        fmtMoney(round2(paid + p)),
        fmtMoney(round2(original * (1 + p/100))),
        fmtMoney(round2(original * (1 - p/100))),
      ];
      const wrong = uniqueStrings(wrongSeeds, correct).slice(0, 12);
      const built = make8OptionsFromCorrect(correct, wrong);

      return {
        q: After a <b>${p}%</b> discount, the price is <b>${fmtMoney(paid)}</b>. What was the original price?,
        hint: Paid = ${100 - p}% of original. Original = paid √∑ ${(100 - p)/100}.,
        options: built.options,
        correctIndex: built.correctIndex
      };
    }

    function genPercentOf(mode) {
      const pListEasy = [10, 20, 25, 50];
      const pList = [5, 10, 12.5, 15, 20, 25, 30, 40, 50];
      const p = (mode === "easy" ? pListEasy : pList)[randInt(0, (mode === "easy" ? pListEasy.length : pList.length) - 1)];
      const n = mode === "hard" ? [96, 84, 72, 120, 160, 180][randInt(0,5)] : [80, 60, 40, 100, 200, 120][randInt(0,5)];

      const ans = round2(n * (p / 100));
      const correct = String(ans);

      const wrongSeeds = [
        String(round2(ans + 2)),
        String(round2(Math.max(0, ans - 2))),
        String(round2(n * ((p + 10)/100))),
        String(round2(n * ((Math.max(1, p - 5))/100))),
        String(round2(n / (p/100))),
        String(n),
        String(p),
        String(round2(ans + 5)),
        String(round2(Math.max(0, ans - 5))),
      ];
      const wrong = uniqueStrings(wrongSeeds, correct).slice(0, 12);
      const built = make8OptionsFromCorrect(correct, wrong);

      return {
        q: What is <b>${p}%</b> of <b>${n}</b>?,
        hint: ${p}% = ${p}/100. Multiply: ${n} √ó ${p}/100.,
        options: built.options,
        correctIndex: built.correctIndex
      };
    }

    function genGST(mode) {
      const base = mode === "hard" ? [68, 74, 88, 96, 112, 135][randInt(0,5)] : [50, 80, 100, 120, 150][randInt(0,4)];
      const gst = 9;
      const totalBill = round2(base * (1 + gst / 100));
      const correct = fmtMoney(totalBill);

      const wrongSeeds = [
        fmtMoney(round2(base + gst)),
        fmtMoney(round2(base * 1.08)),
        fmtMoney(round2(base * 1.10)),
        fmtMoney(round2(base)),
        fmtMoney(round2(base - (gst/100)*base)),
        fmtMoney(round2(totalBill + 2)),
        fmtMoney(round2(Math.max(0, totalBill - 2))),
        fmtMoney(round2(base * (1 + (gst/200)))),
      ];
      const wrong = uniqueStrings(wrongSeeds, correct).slice(0, 12);
      const built = make8OptionsFromCorrect(correct, wrong);

      return {
        q: A bill is <b>${fmtMoney(base)}</b>. GST is <b>${gst}%</b>. What is the total amount?,
        hint: Total = 109% of ${base} = ${base} √ó 1.09.,
        options: built.options,
        correctIndex: built.correctIndex
      };
    }

    function pickQuestion() {
      const mode = modeSel.value;

      // timed modes always mixed
      if (!isWarmup()) {
        const gens = [genDiscount, genIncrease, genReverse, genPercentOf, genGST];
        const fn = gens[randInt(0, gens.length - 1)];
        return fn(mode);
      }

      // warm-up: topic user-controlled
      const topic = topicSel.value;
      const map = {
        mixed:   [genDiscount, genIncrease, genReverse, genPercentOf, genGST],
        discount:[genDiscount],
        increase:[genIncrease],
        reverse: [genReverse],
        of:      [genPercentOf],
        gst:     [genGST],
      };
      const pool = map[topic] || map.mixed;
      const fn = pool[randInt(0, pool.length - 1)];
      return fn(mode);
    }

    // ---------- GAME FLOW ----------
    function startQuiz() {
      enforceTopicRules();

      score = 0;
      total = 0;
      streak = 0;
      qIndex = 0;
      inProgress = true;
      locked = false;
      attemptedThisQ = false;

      feedbackEl.textContent = "";
      hintEl.textContent = "";
      updateScore();

      modeSel.disabled = true;
      if (!isWarmup()) topicSel.disabled = true;

      nextBtn.textContent = "Next Question ‚ñ∂";
      nextBtn.disabled = true;

      nextQuestion();
    }

    function endQuiz() {
      stopTimer();
      inProgress = false;
      locked = true;
      attemptedThisQ = false;

      modeSel.disabled = false;
      enforceTopicRules();

      metaEl.textContent = Quiz finished (${TOTAL_QUESTIONS} questions);
      questionEl.textContent = "‚Äî";
      optionsEl.innerHTML = "";
      timerEl.textContent = isWarmup() ? "‚òï Warm-Up (No Timer)" : "‚è± ‚Äì";
      hintEl.textContent = "";

      feedbackEl.textContent = isWarmup()
        ? "‚úÖ Warm-Up complete! (No score recorded.)"
        : ‚úÖ Quiz complete! Final score: ${score} / ${total};

      nextBtn.textContent = "Restart Quiz ‚Üª";
      nextBtn.disabled = false;
    }

    function resetQuiz() {
      stopTimer();
      inProgress = false;
      locked = false;
      attemptedThisQ = false;

      score = 0;
      total = 0;
      streak = 0;
      qIndex = 0;

      modeSel.disabled = false;
      enforceTopicRules();

      updateScore();
      metaEl.textContent = "Ready";
      questionEl.textContent = "‚Äî";
      hintEl.textContent = "";
      optionsEl.innerHTML = "";
      timerEl.textContent = isWarmup() ? "‚òï Warm-Up (No Timer)" : "‚è± ‚Äì";
      feedbackEl.textContent = "Choose mode (and topic in Warm-Up), then press Start Quiz.";
      nextBtn.textContent = "Start Quiz ‚ñ∂";
      nextBtn.disabled = false;
    }

    function nextQuestion() {
      if (!inProgress) return;
      if (qIndex >= TOTAL_QUESTIONS) { endQuiz(); return; }

      enforceTopicRules();

      stopTimer();
      locked = false;
      attemptedThisQ = false;
      nextBtn.disabled = true;

      feedbackEl.textContent = "";
      hintEl.textContent = "";
      optionsEl.innerHTML = "";

      qIndex++;
      metaEl.textContent = Question ${qIndex} of ${TOTAL_QUESTIONS};

      current = pickQuestion();
      questionEl.innerHTML = current.q;

      renderOptions(current.options, current.correctIndex);
      startTimer();
    }

    function handlePick(card) {
      if (locked || !inProgress) return;

      const isCorrect = card.dataset.correct === "1";
      attemptedThisQ = true;
      nextBtn.disabled = false;

      if (isWarmup()) {
        locked = true;
        if (isCorrect) {
          feedbackEl.textContent = "‚úÖ Correct!";
          card.classList.add("correct");
          launchConfetti(2);
          playCorrectSound();
        } else {
          feedbackEl.textContent = "‚ùå Not quite. Try the next one!";
          hintEl.textContent = "Hint: " + current.hint;
          card.classList.add("wrong");
          playWrongSound();
        }
        return;
      }

      const withinTime = timeLeft > 0;

      locked = true;
      stopTimer();
      total++;

      if (withinTime) {
        if (isCorrect) {
          score += 1;
          streak++;
          feedbackEl.textContent = "‚úÖ Correct!";
          card.classList.add("correct");
          launchConfetti(3);
          playCorrectSound();
        } else {
          streak = 0;
          feedbackEl.textContent = "‚ùå Wrong. Keep going!";
          hintEl.textContent = "Hint: " + current.hint;
          card.classList.add("wrong");
          playWrongSound();
        }
      } else {
        if (isCorrect) {
          score += 0.5;
          streak = 0;
          feedbackEl.textContent = "üü° Correct (after time) ‚Üí +0.5 pts.";
          card.classList.add("correct");
          launchConfetti(1);
          playCorrectSound();
        } else {
          streak = 0;
          feedbackEl.textContent = "‚ùå Wrong (0 pts).";
          hintEl.textContent = "Hint: " + current.hint;
          card.classList.add("wrong");
          playWrongSound();
        }
      }

      updateScore();
    }

    // ---------- EVENTS ----------
    nextBtn.addEventListener("click", () => {
      if (!inProgress) { startQuiz(); return; }
      if (!attemptedThisQ) {
        feedbackEl.textContent = "‚ö†Ô∏è No skipping: please attempt this question first.";
        return;
      }
      nextQuestion();
    });

    resetBtn.addEventListener("click", resetQuiz);

    modeSel.addEventListener("change", () => {
      enforceTopicRules();
      if (!inProgress) {
        timerEl.textContent = isWarmup() ? "‚òï Warm-Up (No Timer)" : "‚è± ‚Äì";
      } else {
        enforceTopicRules();
      }
    });

    topicSel.addEventListener("change", () => {
      enforceTopicRules();
    });

    // ---------- INIT ----------
    enforceTopicRules();
    resetQuiz();
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initPercentageGame);
  } else {
    initPercentageGame();
  }
})();
